Formal software verification involves specifications, an implementation, and a proof that the implementation satisfies the specifications. When an actively-developed implementation evolves, the typical approach is to update the formal specifications and proof accordingly. The old version of specifications is simply relegated to history without attempting to formally relate the old and new versions. This approach is inefficient when the implementation changes to expand on input datatypes while retaining the functionality for legacy inputs. Such implementation changes produce comparable old and new specifications, we propose to formally relate and prove properties about the comparable specifications. A formal relation between comparable specifications could enable the proof engineers to utilize the existing proof infrastructure for proving backward compatibility. We call this process proof evolution: a technique for identifying and relating similarities and changes between comparable specifications and proofs. In this talk, I will present the active development of automated tools for enabling and facilitating proof evolution within Amazon Web Services (AWS).

A particular use case, that has motivated the need of automated tools for proof evolution, occurs at AWS Identity [1]. AWS authenticates and authorizes over 34 trillion requests per day [2]. AWS Identity has a custom language for specifying access control policies and a corresponding authorization engine that determines access rights for each request by evaluating the relevant policies. We use Dafny, a verification-aware programming language, to verify that the authorization implementation satisfies the intended specifications. When there are changes to the policy language and actively-developed Java implementation, proof engineers at AWS are required to manually update Dafny specifications and the corresponding proofs. To help streamline this process, we propose that the specifications and proofs evolve alongside the code.

We identify that quite often proof engineers initiate changes to existing specifications by altering types of objects by removing, augmenting and/or introducing new types. To prove properties between such comparable specifications, a conventional approach is to keep the old and new versions around, and manually build injections (mapping functions) between types within the two versions. The type injections provide the necessary infrastructure for proving properties of interest between the comparable specifications. To reduce the manual effort involved, we have developed and open-sourced an analysis tool called typeCart (name-blend of type and cartography) [3]. typeCart automatically identifies equivalent and inequivalent types between comparable specifications, and generates injections for the equivalent types. The generated injections i) mechanically relate the comparable specifications, ii) remove the need of keeping the two versions of specification around and iii) help proof engineers for proving backward compatibility for specifications. To achieve trustworthiness for the injections, typeCart generates verification contracts for the injections, enabling the Dafny verifier to automatically discharge verification conditions of the generated type injections. 

We are evolving typeCart to equip proof engineers with automated tools to prove compatibility between specifications when we introduce new types and augment existing types. We plan to implement workflows for typeCart integration with the version control system of Dafny-based developments at AWS, and its instrumentation to varying codebases of comparability and size.

\ednote{change to cite}
%[1] https://aws.amazon.com/identity/
%[2] https://aws.amazon.com/blogs/aws/happy-10th-birthday-aws-identity-and-access-management/
%[3] https://github.com/awslabs/typecart


\paragraph{Related Work}
% comment by Rustan via slack
The symDiff and related tools, by Shuvendu Lahiri and others, takes two Boogie programs attempts to prove that they correspond with each other. This has been used extensively at Microsoft. For example, different compilers compile to x86, x64, or ARM, each of those is translated into Boogie, and then symDiff is run to see if the compilers semantically do the same thing for each target architecture. Another example is using the same target language and using two different versions of the compiler, so see if the new version introduced anything surprising. symDiff is implemented by weaving the two given Boogie programs into one other Boogie program that is correct iff the two input programs correspond.
Still, symDiff only compares code, whereas typeCart also carries proofs of code forward.

typeCart is concerned with reasoning about the differences between versions of a spec. A related problem is that of \emph{proof repair} -- automatically fixing a proof when a spec changes. While Dafny's use of SMT solvers makes it somewhat more adaptable, the problem of proof repair has been extensively studied in the context of interactive theorem provers, where users write tactic scripts or explicit proof terms which are not easily portable.
Boite \cite{ext-inductive-types} describes ways to extend inductive types with additional constructors and parameters as well as ways to automatically adapt proofs by examining dependencies. Magaud and Bertot \cite{nat-numbers} examined ways of translating proofs between two different inductive representations of the same concept, using the concrete example of the natural numbers in the Coq proof assistant.  More recently, PUMPKIN PATCH \cite{adapt-proofs} is a plugin for Coq to automatically generate patches for proofs of specifications that have changed. It was further extended into PUMPKIN Pi \cite{proof-repair}, which transports proofs across type equivalences, automatically applies patches, generates tactic scripts, and removes references to previous versions of types. For Coq and similar proof assistants, the problem of proof evolution has been studied purely in the context of proof repair -- indeed, a recent large-scale survey of proof-assistant-based verified software \cite{qed-at-large} includes a section on proof evolution in the context of specification changes, but only discusses attempts to adapt proofs, not to compare specs.

Additionally, typeCart includes some largely-syntactic checks to find equivalent or extended types for which to generate injection functions. The more general problem of finding the differences between two versions of code has long been of independent interest. The standard Unix diff tool \cite{diff}, developed in the 1970's, compares lines of text. More recent work \cite{type-directed-diff} focuses on examining the differences between versions of algebraic data types (including program ASTs) in a generic way. This was developed into a practical and efficient algorithm for computing structured differences of code by Miraldo and Swierstra \cite{algo-diff}.